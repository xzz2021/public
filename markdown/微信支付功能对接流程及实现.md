#### å¾®ä¿¡æ‰«ç æ”¯ä»˜åŠŸèƒ½Nativeå¯¹æ¥æµç¨‹åŠå®ç°(nodejs)

#### åŠŸèƒ½éœ€æ±‚: åœ¨è‡ªå·±çš„ç½‘ç«™è®©ç”¨æˆ·æ‰«ç è¿›è¡Œæ”¯ä»˜

#### æ•´ä½“æµç¨‹

  1. å‰ç«¯å‘èµ·è¯·æ±‚, ä¼ é€’è®¢å•æˆ–æ”¯ä»˜å‚æ•°ç»™åç«¯
  2. åç«¯å°†å‚æ•°æ•´åˆ, åŒ…å«å›è°ƒurl, åŠ å¯†ç­¾ååè°ƒç”¨å¾®ä¿¡api, æˆåŠŸå“åº”åä¼šæ”¶åˆ°å¾®ä¿¡è¿”å›çš„äºŒç»´ç å­—ç¬¦ä¿¡æ¯, äº¤ç»™å‰ç«¯
  3. å‰ç«¯è‡ªè¡Œå°†å­—ç¬¦ç”ŸæˆäºŒç»´ç , ç”¨æˆ·æ‰«ç å, å¾®ä¿¡ä¼šè¯·æ±‚å›è°ƒurlé€šçŸ¥ç»“æœ
  4. åç«¯å›è°ƒæ¥å£è¿›è¡ŒéªŒç­¾,ç„¶åè§£å¯†æ•°æ®, è·å–åé¦ˆ,å˜æ›´è®¢å•æ”¯ä»˜çŠ¶æ€
  5. å‰ç«¯è½®è¯¢çŠ¶æ€, æˆåŠŸè·³è½¬é¡µé¢
  6. å¾®ä¿¡çš„è´§å¸å•ä½æ˜¯åˆ†,æ‰€ä»¥é‡‘é¢å¿…é¡»æ˜¯æ­£æ•´æ•°

  
ä¸‹å›¾åŒ…å«å®Œæ•´æ”¯ä»˜(è®¢å•æ”¯ä»˜/è¡¥å·®ä»·)/é€€æ¬¾(å…¨é¢/éƒ¨åˆ†)
![æµç¨‹å›¾](https://github.com/xzz2021/public/blob/main/image/markdown/wxpay.png?raw=true "mind")

#### å‰ç½®æ¡ä»¶

1. å¿…è¦æ¡ä»¶

   > é€šè¿‡å•†æˆ·å·å’Œå•†æˆ·åç§°(`(éœ€ä¸è¥ä¸šæ‰§ç…§åç§°ä¸€è‡´)`), ç”³è¯·apiè¯ä¹¦,è·å–apiè¯ä¹¦çš„åºåˆ—å·, æ‹¿åˆ°å…¬ç§åŒ™è¯ä¹¦æ–‡ä»¶`apicilent_cert.pem`å’Œ `apicilent_key.pem`, åç»­è¿˜è¦è·å–APIv3å¯†åŒ™ç”¨äºå›è°ƒéªŒç­¾

2. è¯ä¹¦åºåˆ—å·éªŒè¯, ä¸‹é¢å‘½ä»¤è¯»å–è¯ä¹¦æ–‡ä»¶, ä¼šè¾“å‡ºæ­£ç¡®åºåˆ—å·

   ```bash
   openssl x509 -in apiclient_cert.pem -noout -serial
   ```


3. æ ¸å¿ƒä»£ç 

   ```ts
    import * as fs from 'fs';
    import crypto from 'node:crypto';
    import axios from 'axios';

      //  è§£å¯† æŠ¥æ–‡ resource
      async decryptAESGCM(base64Ciphertext: string, nonce: string, associatedData: string) {
        const key = this.apiV3Secret;  
        const enc = new TextEncoder();
        const keyBytes = enc.encode(key);
        const nonceBytes = enc.encode(nonce);
        const adBytes = enc.encode(associatedData);
        const cipherBytes = Uint8Array.from(atob(base64Ciphertext), c => c.charCodeAt(0));
        const cryptoKey = await crypto.subtle.importKey('raw', keyBytes, 'AES-GCM', false, ['decrypt']);
        const decrypted = await crypto.subtle.decrypt( { name: 'AES-GCM', iv: nonceBytes, additionalData: adBytes,tagLength: 128 }, cryptoKey, cipherBytes );
        return JSON.parse(new TextDecoder().decode(decrypted));
      }

     //  è§£å¯† è¯ä¹¦ è·å¾—publicKey
      aesGcmDecrypt({ associatedData, nonce, ciphertext }) {
        const key = Buffer.from(this.apiV3Secret, 'utf8');
        const nonceBuf = Buffer.from(nonce, 'utf8');
        const aadBuf = Buffer.from(associatedData, 'utf8');
        const cipherBuf = Buffer.from(ciphertext, 'base64');
        const tag = cipherBuf.subarray(cipherBuf.length - 16);
        const data = cipherBuf.subarray(0, cipherBuf.length - 16);
        const decipher = crypto.createDecipheriv('aes-256-gcm', key, nonceBuf);
        decipher.setAuthTag(tag);
        decipher.setAAD(aadBuf);
        const decrypted = Buffer.concat([decipher.update(data), decipher.final()]);
        return decrypted.toString('utf8');
      }

      //  ç§åŒ™ç­¾å
      signWithPrivateKey(data: string): string {
          //  privateKeyPath  ç§åŒ™æ–‡ä»¶è·¯å¾„
          // 1. è¯»å–ç§é’¥
          const privateKey = fs.readFileSync(privateKeyPath, 'utf8');
          // 2. åˆ›å»ºç­¾åå™¨
          const sign = crypto.createSign('RSA-SHA256');
          sign.update(data);
          sign.end();
          // 3. ç”Ÿæˆç­¾åï¼ˆBase64ç¼–ç ï¼‰
          const signature = sign.sign(privateKey, 'base64');
          return signature;
      }

      //  ç”Ÿæˆè®¤è¯ hash å€¼
    generateAuthorization(type: string = 'native', body: Partial<WxPayData> | WxRefundData = {}) {
      const newBody = {
        ...body,
        appid: this.appid,
        mchid: this.mchid,
        notify_url: this.notify_url,  // æ”¯ä»˜å›è°ƒåœ°å€
      };
      if (type === 'refund') {
        newBody.notify_url = this.refund_notify_url;   // é€€æ¬¾å›è°ƒåœ°å€
        delete newBody.appid;
        delete newBody.mchid;
      }
      const nonce_str = crypto.randomBytes(16).toString('hex').toUpperCase();
      const timestamp = Math.floor(Date.now() / 1000).toString();
      let message = '';
      switch (type) {
        case 'native':
          message = `POST\n/v3/pay/transactions/native\n${timestamp}\n${nonce_str}\n${JSON.stringify(newBody)}\n`;
          break;
        case 'refund':
          message = `POST\n/v3/refund/domestic/refunds\n${timestamp}\n${nonce_str}\n${JSON.stringify(newBody)}\n`;
          break;
        case 'certificates':
          message = `GET\n/v3/certificates\n${timestamp}\n${nonce_str}\n\n`;
          break;
        default:
          throw new Error('ä¸æ”¯æŒçš„ç±»å‹');
      }
      const signature = this.signWithPrivateKey(message);
      // ä¸å¯æ¢è¡Œ
      const Authorization = `WECHATPAY2-SHA256-RSA2048 mchid="${this.mchid}",nonce_str="${nonce_str}",signature="${signature} ",timestamp="${timestamp}",serial_no="${this.serial_no}"`;
      return { Authorization, body: newBody };
    }
    //  è·å–å¾®ä¿¡å®˜æ–¹ è¿”å›çš„ å•†æˆ·è‡ªå·±çš„  å¹³å°è¯ä¹¦   å¹¶å­˜å‚¨publicKey
      fetchCertificates() {
        const url = `https://api.mch.weixin.qq.com/v3/certificates`;
        try {
          const response = await axios.get(url, {
            headers: {
              Authorization: this.generateAuthorization('certificates')?.Authorization,
              Accept: 'application/json',
            },
          });
          const certificatesArray = (response?.data?.data as CertificateItem[]) || [];
          certificatesArray.forEach(item => {
            this.certificates[item.serial_no] = this.aesGcmDecrypt({
              associatedData: item.encrypt_certificate.associated_data,
              nonce: item.encrypt_certificate.nonce,
              ciphertext: item.encrypt_certificate.ciphertext,
            });
          });
        } catch (_err) {
          throw new Error('è·å–å¹³å°è¯ä¹¦å¤±è´¥');
        }
      }
      //  éªŒç­¾
      async verifySign(params: { timestamp: string | number; nonce: string; serial: string; signature: string; body: Record<string, any> | string }) {
        const { timestamp, nonce, serial, signature, body } = params;
        if (!serial || !signature || !timestamp || !nonce) {
          throw new Error('è¯·æ±‚å¤´è§£æå‡ºçš„å‚æ•°é”™è¯¯æˆ–è€…æœ‰é—æ¼!');
        }
        // è·å–å¹³å°è¯ä¹¦å…¬é’¥
        let publicKey = this.certificates[serial] || '';
        if (!publicKey) {
          await this.fetchCertificates();
          publicKey = this.certificates[serial] || '';
          if (!publicKey) {
            throw new Error(`æœªæ‰¾åˆ°å¹³å°è¯ä¹¦åºåˆ—å·: ${serial}`);
          }
        }
        // æ„é€ ç­¾åå­—ç¬¦ä¸²
        const bodyStr = typeof body === 'string' ? body : JSON.stringify(body);
        const signStr = `${timestamp}\n${nonce}\n${bodyStr}\n`;
        const verify = crypto.createVerify('RSA-SHA256');
        verify.update(signStr);
        verify.end();
        const isVerify = verify.verify(publicKey as crypto.KeyLike, signature, 'base64');
        if (!isVerify) throw new Error('ç­¾åéªŒè¯å¤±è´¥'); 
      }

    //  è·å–å¾®ä¿¡äºŒç»´ç 
      async getWxQrcode(objdata: any) {
        const { Authorization, body } = this.generateAuthorization('native', objdata as WxPayData);
        try {
          const response = await axios.post(this.wxNativePayUrl, body, {
            headers: {
              Authorization,
              'Content-Type': 'application/json',
              Accept: 'application/json',
            },
            timeout: 30000,
          });
          return response.data;
        } catch (error) {
          console.log('ğŸš€ ~ WxPay ~ getWxQrcode ~ error:', error);
          // throw new Error('è·å–å¾®ä¿¡æ”¯ä»˜äºŒç»´ç å¤±è´¥, åŸå› : ' + error?.response?.data);
          return error?.response?.data.message;
        }
      }
    //  å‘èµ·å¾®ä¿¡é€€æ¬¾
    async wechatRefund(objdata: WxRefundData) {
        const { Authorization, body } = this.generateAuthorization('refund', objdata);
        try {
          const response = await axios.post(this.refund_apply_url, body, {
            headers: {
              Authorization,
              'Content-Type': 'application/json',
              Accept: 'application/json',
            },
          });
          return response.data;
        } catch (error: any) {
          // è·å–å¾®ä¿¡è¿”å›çš„é”™è¯¯ä¿¡æ¯
          const errorData = error?.response?.data;
          const errorMessage = errorData?.message || errorData?.code || 'æœªçŸ¥é”™è¯¯';
          // console.log('ğŸš€ ~ WxPay ~ wechatRefund ~ errorData:', errorData);
          throw new Error(`å‘èµ·å¾®ä¿¡é€€æ¬¾å¤±è´¥, åŸå› : ${errorMessage}`);
        }
      }

   ```

#### åç«¯å›è°ƒå¤„ç†

1. å¿…è¦æ¡ä»¶

   > ä»è¯·æ±‚å¤´è·å–å‚æ•°åŠ ä¸ŠåŸå§‹bodyè¯·æ±‚ä½“, ä½¿ç”¨è¯ä¹¦æ ¡éªŒç­¾å,ç¡®ä¿ä¿¡æ¯æ¥è‡ªå¾®ä¿¡å®˜æ–¹
   >
   > å†è§£æè¯·æ±‚ä½“ä¸­çš„resourceåŠ å¯†ä¿¡æ¯
   >
   > æœ€åç¡®ä¿å“åº”çŠ¶æ€ç ä¸º200æˆ–204

2. è·å–å¾®ä¿¡äºŒç»´ç 

    ````ts
      const response = await this.wxPay.getWxQrcode(objdata);
    ````

3. ç­¾åéªŒè¯éœ€è¦: å…ˆè°ƒç”¨å®˜æ–¹æ¥å£æ‹¿åˆ°è‡ªå·±çš„æ‰€æœ‰è¯ä¹¦(æˆ–è®¸å¯ä»¥æœ¬åœ°è¯»å–è·³è¿‡???), è¿›è¡Œè§£å¯†åå†ä»¥ `{åºåˆ—å·:publicKey}`å½¢å¼å­˜å‚¨å¥½,åç»­æ ¡éªŒå…¬åŒ™è¿›è¡Œç­¾åéªŒè¯

   ```ts
       const timestamp = headers['Wechatpay-Timestamp'];
       const nonce = headers['Wechatpay-Nonce'];
       const serial = headers['Wechatpay-Serial'];
       const signature = headers['Wechatpay-Signature'];
       const headerData = { timestamp, nonce, serial, signature };
       //  éªŒç­¾
       await this.wxPay.verifySign({ ...headerData, body: bodyData });
   ```
4. è§£å¯†æŠ¥æ–‡,å¾®ä¿¡å›è°ƒä¼ é€’çš„æ•°æ®é»˜è®¤æ˜¯åŠ å¯†çš„

   ```ts
      const { nonce, ciphertext, associated_data } = bodyData.resource;
      // decryptDataä¸ºè§£å¯†åå¾—åˆ°çš„æ˜æ–‡æ•°æ®
      const decryptData = (await this.wxPay.decryptAESGCM(ciphertext, nonce, associated_data))

   ```

5. é€€æ¬¾

   ```ts
    const refundDataFinal = {
      transaction_id: trade_no,  //  å¾®ä¿¡å¹³å°äº¤æ˜“id
      out_refund_no: refundNo,  //  è‡ªå®šä¹‰é€€æ¬¾å•å·
      //   adjustedNet  é€€æ¬¾é‡‘é¢     //   rawOrderAmount åŸè®¢å•æ”¯ä»˜é‡‘é¢
      amount: { refund: Math.ceil(adjustedNet * 100), total: Math.ceil(rawOrderAmount * 100), currency: 'CNY' },
    };
    const result = await this.wxPay.wechatRefund(refundDataFinal);

   ```