#### å¾®ä¿¡æ‰«ç æ”¯ä»˜åŠŸèƒ½Nativeå¯¹æ¥æµç¨‹åŠå®ç°(nodejs)

##### åŠŸèƒ½éœ€æ±‚: åœ¨è‡ªå·±çš„ç½‘ç«™è®©ç”¨æˆ·æ‰«ç è¿›è¡Œæ”¯ä»˜

##### æ•´ä½“æµç¨‹

  1. å‰ç«¯å‘èµ·è¯·æ±‚, ä¼ é€’è®¢å•æˆ–æ”¯ä»˜å‚æ•°ç»™åç«¯
  2. åç«¯å°†å‚æ•°æ•´åˆ, åŒ…å«å›è°ƒurl, åŠ å¯†ç­¾ååè°ƒç”¨å¾®ä¿¡api, æˆåŠŸå“åº”åä¼šæ”¶åˆ°å¾®ä¿¡è¿”å›çš„äºŒç»´ç å­—ç¬¦ä¿¡æ¯, äº¤ç»™å‰ç«¯
  3. å‰ç«¯è‡ªè¡Œå°†å­—ç¬¦ç”ŸæˆäºŒç»´ç , ç”¨æˆ·æ‰«ç å, å¾®ä¿¡ä¼šè¯·æ±‚å›è°ƒurlé€šçŸ¥ç»“æœ
  4. åç«¯å›è°ƒæ¥å£è¿›è¡ŒéªŒç­¾,ç„¶åè§£å¯†æ•°æ®, è·å–åé¦ˆ,å˜æ›´è®¢å•æ”¯ä»˜çŠ¶æ€
  5. å‰ç«¯è½®è¯¢çŠ¶æ€, æˆåŠŸè·³è½¬é¡µé¢

##### åç«¯è¯·æ±‚äºŒç»´ç 

1. å¿…è¦æ¡ä»¶

   > é€šè¿‡å•†æˆ·å·å’Œå•†æˆ·åç§°(`(éœ€ä¸è¥ä¸šæ‰§ç…§åç§°ä¸€è‡´)`), ç”³è¯·apiè¯ä¹¦,è·å–apiè¯ä¹¦çš„åºåˆ—å·, æ‹¿åˆ°å…¬ç§åŒ™è¯ä¹¦æ–‡ä»¶`apicilent_cert.pem`å’Œ `apicilent_key.pem`, åç»­è¿˜è¦è·å–APIv3å¯†åŒ™ç”¨äºå›è°ƒéªŒç­¾

2. å¿…ä¼ å‚æ•°

   ````ts
       const appid = 'wxb01a75674330';  // å•†æˆ·ç»‘å®šçš„appid
       const mchid = '12453234569';   // å•†æˆ·å·
       const description = 'Imageå½¢è±¡åº—-æ·±åœ³è…¾å¤§-QQå…¬ä»”';
       const out_trade_no = '121775465663233368018';  // è®¢å•å·
       const notify_url = 'https://www.weixin.qq.com/wxpay/pay.php';  // è‡ªå·±çš„åç«¯å›è°ƒé€šçŸ¥åœ°å€
       const amount = { total: 1, currency: 'CNY' };  // é‡‘é¢åŠæ•°æ®æ ¼å¼  å¾®ä¿¡è´§å¸å•ä½æ˜¯åˆ†,æ•…åªæœ‰Intæ•´æ•°
       const serial_no = '24EB7FF415E5DD7FF6F20517520428FE78091650'; // å•†æˆ·è¯ä¹¦åºåˆ—å·
   ````

3. è¯ä¹¦åºåˆ—å·éªŒè¯, ä¸‹é¢å‘½ä»¤è¯»å–è¯ä¹¦æ–‡ä»¶, ä¼šè¾“å‡ºæ­£ç¡®åºåˆ—å·

   ```bash
   openssl x509 -in apiclient_cert.pem -noout -serial
   ```

4. é¢å¤–çš„å¿…é¡»æ··æ·†å‚æ•°

   ```ts
   // nonce_str éœ€è¦32ä½éšæœºå­—ç¬¦,æœ€å¥½å¤§å†™     ä¸‹é¢ä¼ å…¥16 ä¼šç”Ÿæˆ32ä½å­—ç¬¦
   const nonce_str = crypto.randomBytes(16).toString('hex').toUpperCase(); 
   //  timestamp æ—¶é—´æˆ³  ç§’çº§
   const timestamp = Math.floor(Date.now() / 1000).toString();
   
   //  signature ç­¾åå‚æ•°  è¯·æ±‚æ–¹æ³•  è¯·æ±‚url  ä¼ é€’å‚æ•° body
   ```

5.  `signature`éœ€è¦ä½¿ç”¨SHA256åŠ å¯†, è¿”å›base64ç¼–ç ,  åŠ å¯†å‡½æ•°, æ³¨æ„: ç­¾åéœ€è¦è¯»å–è¯ä¹¦æ–‡ä»¶, `privateKeyPath`ä¸ºè¯ä¹¦é¡¹ç›®ç›®å½•

   ```ts
   signWithPrivateKey(bodyStr: string, privateKeyPath: string = 'src/table/payment/cert/apiclient_key.pem'): string {
       // 1. æ ¹æ®ç§åŒ™æ–‡ä»¶è·¯å¾„è¯»å–ç§é’¥
       const privateKey = fs.readFileSync(privateKeyPath, 'utf8');
       // 2. åˆ›å»ºç­¾åå™¨
       const sign = crypto.createSign('RSA-SHA256');
       sign.update(bodyStr);
       sign.end();
       // 3. ç”Ÿæˆç­¾åï¼ˆBase64ç¼–ç ï¼‰
       const signature = sign.sign(privateKey, 'base64');
       return signature;
     }
   ```

6. æ ¸å¿ƒä»£ç 

   ```ts
   // body ä¸ºä¼ å‚å¯¹è±¡  æ³¨æ„``æ¨¡æ¿å­—ç¬¦ä¸²å†…æ˜¯ç©ºæ ¼æ²¡æœ‰æ¢è¡Œ   ä¸€å®šè¦è®¾ç½®è¶…æ—¶æ—¶é—´  å¾®ä¿¡ä¸€èˆ¬å“åº”æ—¶é—´>=10ç§’
   const message = `POST\n/v3/pay/transactions/native\n${timestamp}\n${nonce_str}\n${JSON.stringify(body)}\n`;
   const signature = this.signWithPrivateKey(message);
   const Authorization = `WECHATPAY2-SHA256-RSA2048 mchid="${mchid}",nonce_str="${nonce_str}",signature="${signature}",timestamp="${timestamp}",serial_no="${serial_no}"`;
   const WX_PAY_URL = "https://api.mch.weixin.qq.com/v3/pay/transactions/native"
   const response = await this.httpService.axiosRef.post(WX_PAY_URL, body, {
           headers: {
             'Content-Type': 'application/json',
             Authorization,
             Accept: 'application/json',
           },
           timeout: 30000,
         });
   //  å¦‚æœæˆåŠŸ ä¼šè¿”å› { "code_url" : "weixin://wxpay/bizpayurl/up?pr=NwY5Mz9&groupid=00" }
   ```

##### åç«¯å›è°ƒå¤„ç†

1. å¿…è¦æ¡ä»¶

   > ä»è¯·æ±‚å¤´è·å–å‚æ•°åŠ ä¸ŠåŸå§‹bodyè¯·æ±‚ä½“, ä½¿ç”¨è¯ä¹¦æ ¡éªŒç­¾å,ç¡®ä¿ä¿¡æ¯æ¥è‡ªå¾®ä¿¡å®˜æ–¹
   >
   > å†è§£æè¯·æ±‚ä½“ä¸­çš„resourceåŠ å¯†ä¿¡æ¯
   >
   > æœ€åç¡®ä¿å“åº”çŠ¶æ€ç ä¸º200æˆ–204

2. ç­¾åéªŒè¯éœ€è¦: å…ˆè°ƒç”¨å®˜æ–¹æ¥å£æ‹¿åˆ°è‡ªå·±çš„æ‰€æœ‰è¯ä¹¦(æˆ–è®¸å¯ä»¥æœ¬åœ°è¯»å–è·³è¿‡???), è¿›è¡Œè§£å¯†åå†ä»¥ `{åºåˆ—å·:publicKey}`å½¢å¼å­˜å‚¨å¥½,åç»­æ ¡éªŒå…¬åŒ™è¿›è¡Œç­¾åéªŒè¯

   ```ts
       const timestamp = headers['Wechatpay-Timestamp'];
       const nonce = headers['Wechatpay-Nonce'];
       const serial = headers['Wechatpay-Serial'];
       const signature = headers['Wechatpay-Signature'];
       const headerData = { timestamp, nonce, serial, signature };
   	const body = bodyData;
   ```

   æ ¸å¿ƒä»£ç 

   ```ts
   // æ ¡éªŒç­¾å
   async verifySign(params: {
       timestamp: string | number;
       nonce: string;
       serial: string;
       signature: string;
       body: Record<string, any> | string;
     }): Promise<boolean> {
       const { timestamp, nonce, serial, signature, body } = params;
       // è·å–å¹³å°è¯ä¹¦å…¬é’¥
       let publicKey = this.certificates[serial];
       if (!publicKey) {
         await this.fetchCertificates();
         publicKey = this.certificates[serial];
         if (!publicKey) {
           throw new Error(`æœªæ‰¾åˆ°å¹³å°è¯ä¹¦åºåˆ—å·: ${serial}`);
         }
       }
       // æ„é€ ç­¾åå­—ç¬¦ä¸²
       const bodyStr = typeof body === 'string' ? body : JSON.stringify(body);
       const signStr = `${timestamp}\n${nonce}\n${bodyStr}\n`;
   
       try {
         const verify = crypto.createVerify('RSA-SHA256');
         verify.update(signStr);
         verify.end();
         return verify.verify(publicKey as crypto.KeyLike, signature, 'base64');
       } catch (err) {
         console.error('ç­¾åéªŒè¯å¤±è´¥:', err);
         return false;
       }
     }
     
   //  è·å–å¾®ä¿¡å®˜æ–¹ è¿”å›çš„ å•†æˆ·è‡ªå·±çš„  å¹³å°è¯ä¹¦   å¹¶å­˜å‚¨publicKeyåˆ° this.certificates
     async fetchCertificates() {
       const url = `https://api.mch.weixin.qq.com/v3/certificates`;
       try {
         const response = await axios.get(url, {
           headers: {
             Authorization: this.generateAuthorization('certificates')?.Authorization,
             Accept: 'application/json',
           },
         });
         const certificatesArray = (response?.data?.data as CertificateItem[]) || [];
         certificatesArray.forEach(item => {
           this.certificates[item.serial_no] = this.aesGcmDecrypt({
             associatedData: item.encrypt_certificate.associated_data,
             nonce: item.encrypt_certificate.nonce,
             ciphertext: item.encrypt_certificate.ciphertext,
           });
         });
         // eslint-disable-next-line @typescript-eslint/no-unused-vars
       } catch (_err) {
         throw new Error('è·å–å¹³å°è¯ä¹¦å¤±è´¥');
       }
     }
   
   //  ç§åŒ™ç­¾å  éœ€è¦æ³¨æ„è¯ä¹¦çš„æ–‡ä»¶è·¯å¾„
     signWithPrivateKey(data: string, privateKeyPath: string = 'src/table/payment/cert/apiclient_key.pem'): string {
       //  å¦‚æœæ˜¯æµ‹è¯• ä½¿ç”¨æ–‡ä»¶apiclient_test_key.pem
       // 1. è¯»å–ç§é’¥
       const privateKey = fs.readFileSync(privateKeyPath, 'utf8');
       // 2. åˆ›å»ºç­¾åå™¨
       const sign = crypto.createSign('RSA-SHA256');
       // const sign = crypto.createSign('SHA256');
       sign.update(data);
       sign.end();
       // 3. ç”Ÿæˆç­¾åï¼ˆBase64ç¼–ç ï¼‰
       const signature = sign.sign(privateKey, 'base64');
       return signature;
     }
   
   // ç”ŸæˆåŠ å¯†æ•°æ® Authorization
     generateAuthorization(type: string = 'native', body: Partial<WxPayData> = {}) {
       const newBody = {
         ...body,
         appid: this.appid,
         mchid: this.mchid,
         notify_url: this.notify_url,
       };
       const nonce_str = crypto.randomBytes(16).toString('hex').toUpperCase();
       const timestamp = Math.floor(Date.now() / 1000).toString();
       let message = '';
       switch (type) {
         case 'native':
           message = `POST\n/v3/pay/transactions/native\n${timestamp}\n${nonce_str}\n${JSON.stringify(newBody)}\n`;
           break;
         case 'certificates':
           message = `GET\n/v3/certificates\n${timestamp}\n${nonce_str}\n\n`;
           break;
         default:
           throw new Error('ä¸æ”¯æŒçš„ç±»å‹');
       }
       const signature = this.signWithPrivateKey(message);
       const Authorization = `WECHATPAY2-SHA256-RSA2048 mchid="${this.mchid}",nonce_str="${nonce_str}",signature="${signature}",timestamp="${timestamp}",serial_no="${this.serial_no}"`;
       return { Authorization, body: newBody };
     }
   ```

3. è§£å¯†æŠ¥æ–‡resource, éœ€è¦3ä¸ªå‚æ•°åŠ ä¸ŠapiV3Secret

   ```ts
   //  è§£å¯† æŠ¥æ–‡ resource
     async decryptAESGCM(
       base64Ciphertext: string,
       nonce: string,
       associatedData: string,
     ): Promise<string> {
       const key = apiV3Secret; // Must be 32 bytes (for AES-256)
       const enc = new TextEncoder();
       const keyBytes = enc.encode(key);
       const nonceBytes = enc.encode(nonce);
       const adBytes = enc.encode(associatedData);
       const cipherBytes = Uint8Array.from(atob(base64Ciphertext), (c) =>
         c.charCodeAt(0),
       );
       const cryptoKey = await crypto.subtle.importKey(
         'raw',
         keyBytes,
         'AES-GCM',
         false,
         ['decrypt'],
       );
       const decrypted = await crypto.subtle.decrypt(
         {
           name: 'AES-GCM',
           iv: nonceBytes,
           additionalData: adBytes,
           tagLength: 128,
         },
         cryptoKey,
         cipherBytes,
       );
       return new TextDecoder().decode(decrypted);
     }
   ```

4. å®Œæ•´å°è£…, å¾…ä¼˜åŒ–

   ```ts
   import * as fs from 'fs';
   import * as crypto from 'crypto';
   import axios from 'axios';
   
   interface WxPayData {
     appid: string;
     mchid: string;
     description: string;
     out_trade_no: string;
     notify_url: string;
     amount: { total: number; currency: string };
   }
   
   interface CertificateItem {
     effective_time: string;
     expire_time: string;
     serial_no: string;
     encrypt_certificate: {
       algorithm: string;
       associated_data: string;
       ciphertext: string;
       nonce: string;
     };
   }
   
   export class WxPay {
     private readonly appid: string = 'wxb04564746truya6fa0';
     private readonly mchid: string = '1673452369';
     private readonly notify_url: string = 'https://xzz2021.github.com';
     private readonly serial_no: string = '24EB734642564FE78091650';
     private readonly apiV3Secret: string = '4564563453546562384626433832';
     private readonly wxNativePayUrl: string = 'https://api.mch.weixin.qq.com/v3/pay/transactions/native';
     private readonly privateKeyPath: string = 'src/cert/apiclient_key.pem';  
     private certificates: any = {};
   
     signWithPrivateKey(data: string, privateKeyPath: string = this.privateKeyPath): string {
       //  å¦‚æœæ˜¯æµ‹è¯• ä½¿ç”¨æ–‡ä»¶apiclient_test_key.pem
       // 1. è¯»å–ç§é’¥
       const privateKey = fs.readFileSync(privateKeyPath, 'utf8');
       // 2. åˆ›å»ºç­¾åå™¨
       const sign = crypto.createSign('RSA-SHA256');
       // const sign = crypto.createSign('SHA256');
       sign.update(data);
       sign.end();
       // 3. ç”Ÿæˆç­¾åï¼ˆBase64ç¼–ç ï¼‰
       const signature = sign.sign(privateKey, 'base64');
       return signature;
     }
   
     generateAuthorization(type: string = 'native', body: Partial<WxPayData> = {}) {
       const newBody = {
         ...body,
         appid: this.appid,
         mchid: this.mchid,
         notify_url: this.notify_url,
       };
       const nonce_str = crypto.randomBytes(16).toString('hex').toUpperCase();
       const timestamp = Math.floor(Date.now() / 1000).toString();
       let message = '';
       switch (type) {
         case 'native':
           message = `POST\n/v3/pay/transactions/native\n${timestamp}\n${nonce_str}\n${JSON.stringify(newBody)}\n`;
           break;
         case 'certificates':
           message = `GET\n/v3/certificates\n${timestamp}\n${nonce_str}\n\n`;
           break;
         default:
           throw new Error('ä¸æ”¯æŒçš„ç±»å‹');
       }
       const signature = this.signWithPrivateKey(message);
       const Authorization = `WECHATPAY2-SHA256-RSA2048 mchid="${this.mchid}",nonce_str="${nonce_str}",signature="${signature}",timestamp="${timestamp}",serial_no="${this.serial_no}"`;
   
       return { Authorization, body: newBody };
     }
   
     //  è§£å¯† æŠ¥æ–‡ resource
     async decryptAESGCM(base64Ciphertext: string, nonce: string, associatedData: string): Promise<string> {
       const key = this.apiV3Secret; // Must be 32 bytes (for AES-256)
       const enc = new TextEncoder();
       const keyBytes = enc.encode(key);
       const nonceBytes = enc.encode(nonce);
       const adBytes = enc.encode(associatedData);
       const cipherBytes = Uint8Array.from(atob(base64Ciphertext), c => c.charCodeAt(0));
       const cryptoKey = await crypto.subtle.importKey('raw', keyBytes, 'AES-GCM', false, ['decrypt']);
       const decrypted = await crypto.subtle.decrypt(
         {
           name: 'AES-GCM',
           iv: nonceBytes,
           additionalData: adBytes,
           tagLength: 128,
         },
         cryptoKey,
         cipherBytes,
       );
       return new TextDecoder().decode(decrypted);
     }
   
     //  è§£å¯† è¯ä¹¦ è·å¾—publicKey
     aesGcmDecrypt({ associatedData, nonce, ciphertext }: { associatedData: string; nonce: string; ciphertext: string }): string {
       const key = Buffer.from(this.apiV3Secret, 'utf8');
       const nonceBuf = Buffer.from(nonce, 'utf8');
       const aadBuf = Buffer.from(associatedData, 'utf8');
       const cipherBuf = Buffer.from(ciphertext, 'base64');
   
       const tag = cipherBuf.subarray(cipherBuf.length - 16);
       const data = cipherBuf.subarray(0, cipherBuf.length - 16);
   
       const decipher = crypto.createDecipheriv('aes-256-gcm', key, nonceBuf);
       decipher.setAuthTag(tag);
       decipher.setAAD(aadBuf);
   
       const decrypted = Buffer.concat([decipher.update(data), decipher.final()]);
       return decrypted.toString('utf8');
     }
   
     //  è·å–å¾®ä¿¡å®˜æ–¹ è¿”å›çš„ å•†æˆ·è‡ªå·±çš„  å¹³å°è¯ä¹¦   å¹¶å­˜å‚¨publicKey
     async fetchCertificates() {
       const url = `https://api.mch.weixin.qq.com/v3/certificates`;
       try {
         const response = await axios.get(url, {
           headers: {
             Authorization: this.generateAuthorization('certificates')?.Authorization,
             Accept: 'application/json',
           },
         });
         const certificatesArray = (response?.data?.data as CertificateItem[]) || [];
         certificatesArray.forEach(item => {
           this.certificates[item.serial_no] = this.aesGcmDecrypt({
             associatedData: item.encrypt_certificate.associated_data,
             nonce: item.encrypt_certificate.nonce,
             ciphertext: item.encrypt_certificate.ciphertext,
           });
         });
         // eslint-disable-next-line @typescript-eslint/no-unused-vars
       } catch (_err) {
         throw new Error('è·å–å¹³å°è¯ä¹¦å¤±è´¥');
       }
     }
   
     async verifySign(params: { timestamp: string | number; nonce: string; serial: string; signature: string; body: Record<string, any> | string }) {
       const { timestamp, nonce, serial, signature, body } = params;
       if (!serial || !signature || !timestamp || !nonce) {
         throw new Error('è¯·æ±‚å¤´è§£æå‡ºçš„å‚æ•°é”™è¯¯æˆ–è€…æœ‰é—æ¼!');
       }
       // è·å–å¹³å°è¯ä¹¦å…¬é’¥
       let publicKey = this.certificates[serial] || '';
       if (!publicKey) {
         await this.fetchCertificates();
         publicKey = this.certificates[serial] || '';
         if (!publicKey) {
           throw new Error(`æœªæ‰¾åˆ°å¹³å°è¯ä¹¦åºåˆ—å·: ${serial}`);
         }
       }
       // æ„é€ ç­¾åå­—ç¬¦ä¸²
       const bodyStr = typeof body === 'string' ? body : JSON.stringify(body);
       const signStr = `${timestamp}\n${nonce}\n${bodyStr}\n`;
   
       const verify = crypto.createVerify('RSA-SHA256');
       verify.update(signStr);
       verify.end();
       const isVerify = verify.verify(publicKey as crypto.KeyLike, signature, 'base64');
       if (!isVerify) {
         throw new Error('ç­¾åéªŒè¯å¤±è´¥');
       }
     }
   
     async getWxQrcode(objdata: any) {
       const { Authorization, body } = this.generateAuthorization('native', objdata as WxPayData);
       try {
         const response = await axios.post(this.wxNativePayUrl, body, {
           headers: {
             Authorization,
             'Content-Type': 'application/json',
             Accept: 'application/json',
           },
           timeout: 30000,
         });
         return response.data;
       } catch (error) {
         //   console.log('ğŸš€ ~ WxPay ~ getWxQrcode ~ error:', error);
         // return {
         //   code: 400,
         //   message: 'è·å–å¾®ä¿¡æ”¯ä»˜äºŒç»´ç å¤±è´¥',
         //   error: error?.response?.data,
         // };
         throw new Error('è·å–å¾®ä¿¡æ”¯ä»˜äºŒç»´ç å¤±è´¥, åŸå› : ' + error?.response?.data);
       }
     }
   }
   
   ```

   



























