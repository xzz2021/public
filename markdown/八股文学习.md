##### 记录回顾八股文知识点,常学常新!

1. position属性

   > static relative absolute sticky

2. vue中watch,computed属性和区别

   > **watch** 不支持缓存,可异步(适合开销大的操作),deep, immediate
   >
   > **computed** 支持缓存(根据依赖数据变化而变化),不能异步

3. vue中watch如何取消?

   > 和setTimeout类似,watch函数本身会返回一个停止函数供调用

4. 常见的http状态码

   > - **1xx 信息响应**。 收到并理解的请求。 请求处理将继续。
   > - **2xx 成功**。200-请求成功, 201-请求并处理成功, 202-已接收但未处理完成
   > - **3xx 重定向**。 301-永久重定向, 302-临时重定向
   > - **4xx 客户端错误**。 400-缺少数据,403-没有权限,404-找不到资源
   > - **5xx 服务器错误**。 服务器遇到错误，无法满足请求。

5. 如何判断一个值是否是数组

   > 1. ```js
   >    let a = [];
   >    a instanceof Array; //true  // 实例的构造函数属性constructor指向构造函数
   >    ```
   >
   > 2. ```js
   >    let a = [1,3,4];
   >    a.constructor === Array;//true  // 检测Array.prototype属性  但prototype是可更改的 不一定准确
   >    ```
   >
   > 3. ```js
   >    let a = [1,2,3]
   >    Object.prototype.toString.call(a) === '[object Array]';//true  //可以检验所有其他类型  适用不同环境
   >    ```
   >
   > 4. ```js
   >    let a = [1,2,3]
   >    Array.isArray(a);//true   //新方法  推荐
   >    ```

6. typeof 和instanceof的区别

   > `typeof` 操作符返回一个字符串，表示未经计算的操作数的`类型`
   >
   > ```js
   > typeof 1 // 'number'
   > typeof '1' // 'string'
   > typeof undefined // 'undefined'
   > typeof true // 'boolean'
   > typeof Symbol() // 'symbol'
   > typeof null // 'object'  // <----
   > typeof [] // 'object'
   > typeof {} // 'object'
   > typeof console // 'object'
   > typeof console.log // 'function'
   > ```
   >
   > `instanceof` 运算符用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上
   >
   > 也就是判断变量是否由指定的构造函数new生成,会顺原型链一直查找,返回`布尔值`
   >
   > ```js
   > // 定义构建函数
   > let Car = function() {}
   > let benz = new Car()
   > benz instanceof Car // true
   > let car = new String('xxx')
   > car instanceof String // true
   > let str = 'xxx'
   > str instanceof String // false
   > ```
   >
   > **通用数据类型判断函数封装**
   >
   > ```js
   > function getType(obj){
   >   let type  = typeof obj;
   >   if (type !== "object") {    // 先进行typeof判断，如果是基础数据类型，直接返回
   >     return type;
   >   }
   >   // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果
   >   return Object.prototype.toString.call(obj).replace(/^\[object (\S+)\]$/, '$1'); 
   > }
   > ```

7. es6-es10新增特性

   >1. let const
   >2. 参数默认值
   >3. 箭头函数
   >4. Class
   >5. 扩展操作符, 可选链操作符`?`, 解构赋值, 模版字符, 数值分隔符`_`, 指数操作符`**`
   >6. promise, async/await
   >7. Generator
   >8. Symbol, BigInt
   >9. Proxy, Reflect
   >10. Map, Set
   >11. 数组对象新增方法,for in of 遍历

8. vue router 和route 区别

9. 重绘和重排

   >- 重绘：某些元素的外观被改变，例如：元素的填充颜色
   >- 重排：重新生成布局，重新排列元素。
   >
   >

10. 项目第一次加载太慢优化

    > gzip  路由懒加载 

11. sessionstorage cookie localstorage 区别

    > cookie与服务器来回传递,限制大小4k,同源窗口可共享, 每次http请求都会携带
    >
    > sessionStorage仅当前会话窗口有效, 5M
    >
    > localStorage用作持久数据,同源窗口可共享,5M

12. 闭包

    >函数内部可以访问到外部的变量
    >
    >应用:  创建私有变量, 延长变量的生命周期, (柯里化函数,高阶函数)
    >
    >```js
    >function create_counter(initial) {
    >    let x = initial || 0;    //  相当于模拟实现了java的私有变量
    >    return {
    >        inc: function () {
    >            x += 1;
    >            return x;
    >        }
    >    }
    >}
    >let c1 = create_counter();
    >c1.inc(); // 1   //  函数每次调用都会循作用域链向上寻找引用的变量
    >c1.inc(); // 2
    >c1.inc(); // 3
    >```
    >
    >```js
    >function getArea(width) {   //  柯里化
    >    return height => {
    >        return width * height
    >    }
    >}
    >const getTenWidthArea = getArea(10)
    >const area1 = getTenWidthArea(20)
    >```
    >
    >

13. 深拷贝浅拷贝

    >浅拷贝, 只拷贝一层,只拷贝基本类型数据的值, 引用类型拷贝的是内存地址(`Object.assign` `slice()`, `concat()` `扩展运算符`)
    >
    >深拷贝,在内存开辟一个新的栈，两个对象属性完全相同，但是对应两个不同的内存地址(`JSON.stringify()` `手写递归循环`)
    >
    >注意: JSON.stringify()弊端---会忽略`undefined`、`symbol`和`函数`

14. 防重复点击方案

    > 前端: 
    >
    > 1. http取消重复请求,axios使用cancelToken
    > 2. 二次封装请求函数,形参传入boolean值, 类似建立flag, 可结合节流控制间隔时间, 面向切片编程AOP思想
    > 3. 
    >
    > 后端: 其实没必要判断,直接做防抖
    >
    > 1. 使用redis缓存一定时间内请求的数据,并使用userid或其他唯一标识符作缓存判断
    >

15. 防抖和节流

    >**防抖是将多次执行变成最后一次执行；节流是将多次执行变为每隔一段时间执行一次。**
    >
    >- 防抖: n 秒后再执行，若在 n 秒内被重复触发，则重新计时; 应用场景: 远程搜索,表单校验; 分`非立即执行版` 和 `立即执行版`
    >
    >  ```js
    >  function debounce(func, wait) {
    >      let timeout;
    >      return function(...args) {
    >          const context = this;
    >          clearTimeout(timeout);
    >          timeout = setTimeout(() => func.apply(context, args), wait);
    >      };
    >  }
    >  ```
    >
    >- 节流: n 秒内只运行一次，若在 n 秒内重复触发，只有一次生效; 分`首节流` `尾节流` 和 `兼顾型节流`
    >
    >  ```js
    >  function throttle(func, wait) {
    >      let timeout, lastExecutionTime = 0;
    >      return function(...args) {
    >          const context = this;
    >          const now = Date.now();
    >          const remainingTime = wait - (now - lastExecutionTime);
    >          if (remainingTime <= 0) {
    >              clearTimeout(timeout);
    >              lastExecutionTime = now;
    >              func.apply(context, args);
    >          } else if (!timeout) {
    >              timeout = setTimeout(() => {
    >                  lastExecutionTime = Date.now();
    >                  timeout = null;
    >                  func.apply(context, args);
    >              }, remainingTime);
    >          }
    >      };
    >  }
    >  ```

16. webScoket的了解，以及有哪些API

    >

17. promise的理解

    > 

18. vue2,vue3 中 v-for 和v-if的优先级

    >vue2: for>if
    >
    >```html
    ><div v-for="item in [1, 2, 3, 4, 5]" v-if="item != 2"></div>
    >```
    >
    >```js
    >function(item) {   // 先循环 后判断
    >     return (item != 2) ? _c('div') : _e()  // _c()渲染节点  _e()注释节点
    >     }
    >```
    >
    >vue3: if>for
    >
    >```html
    > <template v-if="item !== 2">
    >	<div v-for="item in [1, 2, 3, 4, 5]"></div>
    > <template v-if="item !== 2">
    >```
    >
    >推荐写法:  外层包裹template,  使用 `v-for` 内层使用 `v-if`

19. canvas的理解

20. 后台管理系统权限功能菜单和按钮权限如何实现的

21. vue 响应式数据原理: `依赖收集`和`依赖更新`

    > - 在vue2中，使用的数据劫持方法是`Object.defineProperty`这个api，在get中进行`depend`依赖收集，在set中进行`notify`通知依赖的watcher去重新渲染（视图更新）, 通过observe一个对象进行数据劫持
    > - vue3使用的proxy, 监听对象本身

22. 任务队列微任务和宏任务   `JS 执行过程中会产生两种任务：同步任务和异步任务。异步任务会通过任务队列机制进行协调!`

    > 宏任务是指浏览器的事件循环中的一类任务。每次事件循环都会从任务队列中取出一个宏任务来执行，然后再检查微任务队列,
    >
    > 并依次执行所有的微任务。只有在微任务队列清空后，事件循环才会继续处理下一个宏任务。
    >
    > **根本区别** 宏任务：DOM渲染后触发，如setTimeout    微任务：DOM渲染前触发，如Promise
    >
    > 常见的宏任务：setTimeout`  `setInterval`  `setImmediate` (Node.js 环境下)   `  `I/O` 操作 `UI 渲染`
    >
    > 常见的微任务:  `Promise.then/catch/finally`  `MutationObserver`  `process.nextTick` (Node.js 环境下)

23. call apply bind 区别

    > call功能: 调用函数, 改变函数this指向, 返回原有函数返回值  ====  call(this指向, 函数参数)
    >
    > apply功能: 调用函数, 改变函数this指向, 返回原有函数返回值  ==== apply(this指向, 参数放在数组里)
    >
    > bind功能: 改变函数this指向,创建新指向函数, 返回新函数  ==== bind(this指向)

24. vue组件通信方案

    >1. props
    >2. ref $emit   mitter  $parent $root  $attrs  $listeners
    >3. eventBus
    >4. vuex pinia
    >6. provide 与 inject
    >
    >
